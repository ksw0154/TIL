```javascript
function solution(numbers) {
  let strings = numbers.map((num) => num + "");

  const answer = strings.sort((a, b) => b + a - (a + b));
  // const answer = strings.sort((a, b) => b + a - (a + b)).join("");
  return answer[0] === "0" ? "0" : answer;
}

let numbers = [3, 30, 34, 5, 9];
console.log(solution(numbers));
```

풀이입니다.

방식만 이해하면 간단한 풀이었습니다.

우선 strings 변수에 map()을 이용하여 배열의 숫자를 문자열로 변환하여 배열을 만들어줍니다.

그 후에 sort((a, b) => (b + a) - (a + b)) 을 이용하여 큰수의 조합 순으로 정렬해줍니다.

예를 들어 ["6", "10", "2"] 라고 치면 처음 a는 "6" b는 "10"이니까 106 - 610은 음수값이 나오니까

순서가 바뀌지 않습니다. 반대로 "10"과 "2"는 210 - 102가 되면 양수값이 나오기 때문에 순서가 바뀌어서 정렬됩니다.

그렇게 ["6", "2", "10"] 으로 정렬이 완료되면 join("")을 이용하여 "6210"을 만들어주면 됩니다.

마지막에 answer[0]이 "0" 일 경우에는 그냥 "0"을 리턴해주면 되는데

일종의 방어코드로 만약 numbers 배열 인자가 [0,0,0,0] 이런식이면 answer에 "0000"이 할당되기 때문에

이런 경우에는 "0"을 리턴해주어야 하기 때문에 해당 코드를 추가해줬습니다.

설명
compareFunction이 제공되지 않으면 요소를 문자열로 변환하고 유니 코드 코드 포인트 순서로 문자열을 비교하여 정렬됩니다. 예를 들어 "바나나"는 "체리"앞에옵니다. 숫자 정렬에서는 9가 80보다 앞에 오지만 숫자는 문자열로 변환되기 때문에 "80"은 유니 코드 순서에서 "9"앞에옵니다.

compareFunction이 제공되면 배열 요소는 compare 함수의 반환 값에 따라 정렬됩니다. a와 b가 비교되는 두 요소라면,

compareFunction(a, b)이 0보다 작은 경우 a를 b보다 낮은 색인으로 정렬합니다. 즉, a가 먼저옵니다.
compareFunction(a, b)이 0을 반환하면 a와 b를 서로에 대해 변경하지 않고 모든 다른 요소에 대해 정렬합니다. 참고 : ECMAscript 표준은 이러한 동작을 보장하지 않으므로 모든 브라우저(예 : Mozilla 버전은 적어도 2003 년 이후 버전 임)가 이를 존중하지는 않습니다.
compareFunction(a, b)이 0보다 큰 경우, b를 a보다 낮은 인덱스로 소트합니다.
compareFunction(a, b)은 요소 a와 b의 특정 쌍이 두 개의 인수로 주어질 때 항상 동일한 값을 반환해야합니다. 일치하지 않는 결과가 반환되면 정렬 순서는 정의되지 않습니다.
따라서 compare 함수의 형식은 다음과 같습니다.
